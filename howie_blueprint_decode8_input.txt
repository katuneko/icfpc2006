howie
xyzzy
adventure
north
take bolt
take spring
incinerate spring
take button
take processor
take pill
incinerate pill
take radio
take cache
combine processor with cache
take blue transistor
combine radio with blue transistor
take antenna
incinerate antenna
take screw
take motherboard
combine motherboard with screw
take A-1920-IXB
combine A-1920-IXB with bolt
combine A-1920-IXB with processor
combine A-1920-IXB with radio
take red transistor
combine A-1920-IXB with red transistor
combine motherboard with A-1920-IXB
take keypad
combine keypad with motherboard
combine keypad with button
south
use keypad
incinerate keypad
take /etc/passwd
incinerate /etc/passwd
take note
incinerate note
take downloader
take uploader
incinerate downloader
east
east
north
take battery
take buff F-6678-DYP
incinerate buff F-6678-DYP
take olive-green R-4292-FWH
incinerate olive-green R-4292-FWH
take green D-4832-HUX
incinerate green D-4832-HUX
take prussian-blue P-1623-WEU
take black X-9887-GKK
incinerate black X-9887-GKK
take reciprocating H-9887-MUQ
combine battery with reciprocating H-9887-MUQ
take bright-violet T-4292-BHD
combine prussian-blue P-1623-WEU with bright-violet T-4292-BHD
take flax D-4292-HRJ
incinerate flax D-4292-HRJ
take yellow Z-1623-COC
combine yellow Z-1623-COC with prussian-blue P-1623-WEU
take goldenrod X-0010-TVP
incinerate goldenrod X-0010-TVP
take forest-green F-6678-DYP
incinerate forest-green F-6678-DYP
take sky-blue N-1623-ATY
incinerate sky-blue N-1623-ATY
take rotating H-6678-ZJL
incinerate rotating H-6678-ZJL
take sienna T-6678-BEN
incinerate sienna T-6678-BEN
take heliotrope D-5065-UGE
incinerate heliotrope D-5065-UGE
take sea-green N-1623-ATY
incinerate sea-green N-1623-ATY
take ochre D-4292-HRJ
incinerate ochre D-4292-HRJ
take cream Z-1623-COC
incinerate cream Z-1623-COC
take powder-blue T-6678-BEN
incinerate powder-blue T-6678-BEN
take gold N-4832-NFF
take burnt-umber V-0010-XLT
take bronze J-9247-ICW
incinerate bronze J-9247-ICW
take selective-yellow N-4832-NFF
incinerate selective-yellow N-4832-NFF
take peach-puff F-6678-DYP
incinerate peach-puff F-6678-DYP
take bright-violet N-4832-NFF
incinerate bright-violet N-4832-NFF
take moccasin N-4832-NFF
incinerate moccasin N-4832-NFF
take royal-blue J-9247-ICW
combine yellow Z-1623-COC with royal-blue J-9247-ICW
combine yellow Z-1623-COC with burnt-umber V-0010-XLT
combine battery with yellow Z-1623-COC
take pale-mauve R-4292-FWH
incinerate pale-mauve R-4292-FWH
take lavender-blush N-6458-NIT
incinerate lavender-blush N-6458-NIT
take mint-green J-9887-IFM
incinerate mint-green J-9887-IFM
take olive-drab N-1623-ATY
incinerate olive-drab N-1623-ATY
take violet F-4292-DCF
incinerate violet F-4292-DCF
take gray30 X-9247-GHU
incinerate gray30 X-9247-GHU
take pale-blue V-9887-KAO
incinerate pale-blue V-9887-KAO
take steel-blue N-4832-NFF
incinerate steel-blue N-4832-NFF
take pale-magenta N-1623-ATY
incinerate pale-magenta N-1623-ATY
take pale-cornflower-blue X-9247-GHU
incinerate pale-cornflower-blue X-9247-GHU
take low-carb N-4832-NFF
incinerate low-carb N-4832-NFF
take peach-orange P-5065-WBG
incinerate peach-orange P-5065-WBG
take green L-6458-RXX
incinerate green L-6458-RXX
take eggplant Z-1623-COC
combine battery with eggplant Z-1623-COC
take camouflage-green J-9247-ICW
combine battery with camouflage-green J-9247-ICW
take violet-eggplant N-4832-NFF
incinerate violet-eggplant N-4832-NFF
take pear N-4832-NFF
incinerate pear N-4832-NFF
take navy-blue J-9247-ICW
incinerate navy-blue J-9247-ICW
take burgundy F-6678-DYP
combine battery with burgundy F-6678-DYP
combine battery with gold N-4832-NFF
combine uploader with battery
south
east
south
take tea-green T-9887-OKW
take chartreuse N-5065-ALO
take dim-gray X-6458-TNF
take scarlet J-9247-IWC
combine scarlet J-9247-IWC with dim-gray X-6458-TNF
combine chartreuse N-5065-ALO with scarlet J-9247-IWC
take mustard D-4292-HMN
combine mustard D-4292-HMN with tea-green T-9887-OKW
take turquoise N-4832-NAJ
take turquoise F-6678-DTT
combine chartreuse N-5065-ALO with turquoise F-6678-DTT
combine chartreuse N-5065-ALO with mustard D-4292-HMN
take celadon T-9887-OKW
incinerate celadon T-9887-OKW
take burnt-orange T-9887-OKW
take cadet-blue T-9887-OKW
take pastel-green F-6678-DTT
combine chartreuse N-5065-ALO with burnt-orange T-9887-OKW
combine chartreuse N-5065-ALO with cadet-blue T-9887-OKW
combine chartreuse N-5065-ALO with pastel-green F-6678-DTT
combine chartreuse N-5065-ALO with turquoise N-4832-NAJ
take prussian-blue X-6458-TNF
incinerate prussian-blue X-6458-TNF
take magenta X-6458-TNF
incinerate magenta X-6458-TNF
take safety-orange F-6678-DTT
incinerate safety-orange F-6678-DTT
take imported B-5065-YQM
incinerate imported B-5065-YQM
take puce X-6458-TNF
incinerate puce X-6458-TNF
take water-logged F-6678-DTT
incinerate water-logged F-6678-DTT
take thistle-colored X-6458-TNF
incinerate thistle-colored X-6458-TNF
take gamboge T-9887-OKW
combine chartreuse N-5065-ALO with gamboge T-9887-OKW
take sky-blue T-9887-OKW
incinerate sky-blue T-9887-OKW
take navy-blue MOSFET
incinerate navy-blue MOSFET
take olive-green N-5065-ALO
take pastel-pink Z-4832-PUL
take seashell D-1403-UXS
incinerate seashell D-1403-UXS
take peach-yellow D-1403-UXS
incinerate peach-yellow D-1403-UXS
take crimson V-0010-XGX
take cyan J-9247-IWC
incinerate cyan J-9247-IWC
take puce H-0010-ZBZ
incinerate puce H-0010-ZBZ
take chocolate-colored D-1403-UXS
combine pastel-pink Z-4832-PUL with chocolate-colored D-1403-UXS
combine pastel-pink Z-4832-PUL with crimson V-0010-XGX
combine pastel-pink Z-4832-PUL with olive-green N-5065-ALO
take pale-brown V-9247-KRE
incinerate pale-brown V-9247-KRE
take heliotrope D-1403-UXS
incinerate heliotrope D-1403-UXS
take crimson MOSFET
combine crimson MOSFET with pastel-pink Z-4832-PUL
combine crimson MOSFET with chartreuse N-5065-ALO
combine uploader with crimson MOSFET
north
take gray60 Z-4292-PRV
take pale-carmine D-9887-UUE
incinerate pale-carmine D-9887-UUE
take pale-cornflower-blue D-9887-UUE
incinerate pale-cornflower-blue D-9887-UUE
take imported D-9887-UUE
incinerate imported D-9887-UUE
take gray90 Z-4292-PRV
take sepia Z-4292-PRV
combine gray90 Z-4292-PRV with sepia Z-4292-PRV
take gray30 D-9887-UUE
incinerate gray30 D-9887-UUE
take robin-egg-blue Z-4292-PRV
combine gray60 Z-4292-PRV with robin-egg-blue Z-4292-PRV
take slate-blue D-9887-UUE
incinerate slate-blue D-9887-UUE
take rosy-brown D-9887-UUE
incinerate rosy-brown D-9887-UUE
take gray50 Z-4292-PRV
take misty-rose Z-4292-PRV
incinerate misty-rose Z-4292-PRV
take cinnamon Z-9887-CUG
incinerate cinnamon Z-9887-CUG
take saffron N-9247-AWO
incinerate saffron N-9247-AWO
take indigo V-4292-XRX
incinerate indigo V-4292-XRX
take pale-sandy-brown R-4832-FAV
incinerate pale-sandy-brown R-4832-FAV
take momemtum-preserving Z-0010-PGL
incinerate momemtum-preserving Z-0010-PGL
take swamp-green V-4292-XRX
incinerate swamp-green V-4292-XRX
take pale-pink R-1623-SOQ
incinerate pale-pink R-1623-SOQ
take cream R-1623-SOQ
incinerate cream R-1623-SOQ
take royal-blue B-9247-YCM
incinerate royal-blue B-9247-YCM
take burgundy J-1403-IIC
incinerate burgundy J-1403-IIC
take blue Z-0010-PGL
incinerate blue Z-0010-PGL
take pink Z-0010-PGL
incinerate pink Z-0010-PGL
take moss-green F-4832-DFT
incinerate moss-green F-4832-DFT
take pine-green B-9247-YCM
incinerate pine-green B-9247-YCM
take floating R-4832-FAV
incinerate floating R-4832-FAV
take russet R-4832-FAV
incinerate russet R-4832-FAV
take lavender-blush D-9887-UUE
incinerate lavender-blush D-9887-UUE
take old-gold N-9247-AWO
incinerate old-gold N-9247-AWO
take pear N-9247-AWO
incinerate pear N-9247-AWO
take pastel-pink D-9887-UUE
incinerate pastel-pink D-9887-UUE
take heliotrope D-9887-UUE
incinerate heliotrope D-9887-UUE
take persian-blue Z-4292-PRV
incinerate persian-blue Z-4292-PRV
take emerald Z-4292-PRV
incinerate emerald Z-4292-PRV
take violet-red Z-4292-PRV
take blaze-orange Z-4292-PRV
incinerate blaze-orange Z-4292-PRV
take RS232 adapter
combine RS232 adapter with gray90 Z-4292-PRV
combine RS232 adapter with gray60 Z-4292-PRV
take jade D-9887-UUE
incinerate jade D-9887-UUE
take steel-blue D-9887-UUE
combine RS232 adapter with steel-blue D-9887-UUE
combine RS232 adapter with violet-red Z-4292-PRV
combine RS232 adapter with gray50 Z-4292-PRV
examine RS232 adapter
combine uploader with RS232 adapter
north
take old X-1623-GTO
incinerate old X-1623-GTO
take corn V-0010-XBD
incinerate corn V-0010-XBD
take blue-violet P-4832-JFJ
incinerate blue-violet P-4832-JFJ
take gamboge X-0010-TLX
incinerate gamboge X-0010-TLX
take denim D-4292-HHR
incinerate denim D-4292-HHR
take low-carb D-5065-UVM
incinerate low-carb D-5065-UVM
take pear V-9247-KMI
incinerate pear V-9247-KMI
take ultramarine J-9247-IRG
incinerate ultramarine J-9247-IRG
take pink D-4292-HHR
incinerate pink D-4292-HHR
take discounted L-6458-RNH
incinerate discounted L-6458-RNH
take flax D-4292-HHR
incinerate flax D-4292-HHR
take cinnamon J-9247-IRG
incinerate cinnamon J-9247-IRG
take lemon F-9887-QAE
incinerate lemon F-9887-QAE
take low-carb X-1623-GTO
incinerate low-carb X-1623-GTO
take amethyst J-9247-IRG
incinerate amethyst J-9247-IRG
take reverse-chirality J-9247-IRG
incinerate reverse-chirality J-9247-IRG
take lemon T-9887-OFC
incinerate lemon T-9887-OFC
take honeydew B-4292-LWV
incinerate honeydew B-4292-LWV
take white F-9887-QAE
incinerate white F-9887-QAE
take black B-4292-LWV
incinerate black B-4292-LWV
take spring-green V-9247-KMI
incinerate spring-green V-9247-KMI
take pale-goldenrod V-0010-XBD
incinerate pale-goldenrod V-0010-XBD
take sangria X-1623-GTO
incinerate sangria X-1623-GTO
take lawn-green N-1623-AJI
incinerate lawn-green N-1623-AJI
take imitation R-1403-SXU
incinerate imitation R-1403-SXU
take sapphire X-1623-GTO
incinerate sapphire X-1623-GTO
take sea-green Z-4832-PPP
incinerate sea-green Z-4832-PPP
take gray10 F-9887-QAE
incinerate gray10 F-9887-QAE
take sandy-brown Z-1623-CEK
incinerate sandy-brown Z-1623-CEK
take gray90 R-4292-FMP
incinerate gray90 R-4292-FMP
take sturdy V-9887-KPW
incinerate sturdy V-9887-KPW
take camouflage-green J-6458-VDL
incinerate camouflage-green J-6458-VDL
take sturdy J-6458-VDL
incinerate sturdy J-6458-VDL
take wisteria X-9247-GWE
incinerate wisteria X-9247-GWE
take persian-blue F-9887-QAE
incinerate persian-blue F-9887-QAE
take sturdy Z-1623-CEK
incinerate sturdy Z-1623-CEK
take pastel-pink X-1623-GTO
incinerate pastel-pink X-1623-GTO
take sapphire R-1403-SXU
incinerate sapphire R-1403-SXU
take heliotrope J-6458-VDL
incinerate heliotrope J-6458-VDL
take mustard Z-4832-PPP
incinerate mustard Z-4832-PPP
take wisteria X-6458-TIJ
incinerate wisteria X-6458-TIJ
take coral Z-4832-PPP
incinerate coral Z-4832-PPP
take gray80 X-1623-GTO
incinerate gray80 X-1623-GTO
take ivory X-1623-GTO
incinerate ivory X-1623-GTO
take raw-umber T-0010-BQH
take foreign V-9247-KMI
incinerate foreign V-9247-KMI
take imaginary T-0010-BQH
take snow X-1623-GTO
incinerate snow X-1623-GTO
take prussian-blue T-0010-BQH
incinerate prussian-blue T-0010-BQH
take gray-tea-green T-0010-BQH
incinerate gray-tea-green T-0010-BQH
take miniature V-9247-KMI
incinerate miniature V-9247-KMI
take steel-blue V-9247-KMI
incinerate steel-blue V-9247-KMI
take indigo T-0010-BQH
incinerate indigo T-0010-BQH
take EPROM burner
take brass X-1623-GTO
combine brass X-1623-GTO with imaginary T-0010-BQH
combine EPROM burner with brass X-1623-GTO
combine EPROM burner with raw-umber T-0010-BQH
examine EPROM burner
combine uploader with EPROM burner
north
take moccasin N-4292-NWT
take gray-tea-green L-4832-RPN
take pale-chestnut T-9247-OHI
incinerate pale-chestnut T-9247-OHI
take pale-cornflower-blue V-6458-XDJ
incinerate pale-cornflower-blue V-6458-XDJ
take misty-rose T-9247-OHI
incinerate misty-rose T-9247-OHI
take sangria N-4292-NWT
take jade P-1403-WSU
combine jade P-1403-WSU with moccasin N-4292-NWT
take yellow-green P-6678-JEZ
combine yellow-green P-6678-JEZ with jade P-1403-WSU
take crimson P-6678-JEZ
combine crimson P-6678-JEZ with gray-tea-green L-4832-RPN
combine crimson P-6678-JEZ with sangria N-4292-NWT
take scarlet Z-5065-CGQ
combine crimson P-6678-JEZ with scarlet Z-5065-CGQ
take organic T-9247-OHI
incinerate organic T-9247-OHI
take bright-turquoise J-1623-ITM
take mint-green X-4832-TKP
combine crimson P-6678-JEZ with bright-turquoise J-1623-ITM
combine crimson P-6678-JEZ with mint-green X-4832-TKP
take denim T-9247-OHI
incinerate denim T-9247-OHI
take gray30 X-4832-TKP
incinerate gray30 X-4832-TKP
take gray60 T-9247-OHI
incinerate gray60 T-9247-OHI
take azure H-6458-ZXL
combine azure H-6458-ZXL with yellow-green P-6678-JEZ
combine azure H-6458-ZXL with crimson P-6678-JEZ
take carmine D-6678-HJX
take cornflower-blue D-6678-HJX
incinerate cornflower-blue D-6678-HJX
take tan D-6678-HJX
combine tan D-6678-HJX with carmine D-6678-HJX
take pale-mauve L-4832-RPN
take robin-egg-blue D-6678-HJX
incinerate robin-egg-blue D-6678-HJX
take sandy-brown P-1403-WSU
incinerate sandy-brown P-1403-WSU
take cadet-blue H-9247-MMG
take pale-brown P-1403-WSU
incinerate pale-brown P-1403-WSU
take gray40 L-4832-RPN
combine gray40 L-4832-RPN with cadet-blue H-9247-MMG
take cream H-9247-MMG
combine gray40 L-4832-RPN with cream H-9247-MMG
take status LED
combine status LED with pale-mauve L-4832-RPN
take black D-6678-HJX
combine gray40 L-4832-RPN with black D-6678-HJX
combine tan D-6678-HJX with gray40 L-4832-RPN
take periwinkle D-6678-HJX
combine status LED with periwinkle D-6678-HJX
take violet D-6678-HJX
combine status LED with violet D-6678-HJX
take old-lace D-6678-HJX
incinerate old-lace D-6678-HJX
take navy-blue D-6678-HJX
combine status LED with navy-blue D-6678-HJX
combine status LED with tan D-6678-HJX
take burnt-sienna D-6678-HJX
incinerate burnt-sienna D-6678-HJX
take peppered D-6678-HJX
combine status LED with peppered D-6678-HJX
take moss-green D-6678-HJX
incinerate moss-green D-6678-HJX
take gross D-6678-HJX
incinerate gross D-6678-HJX
take prussian-blue D-6678-HJX
combine status LED with prussian-blue D-6678-HJX
combine status LED with azure H-6458-ZXL
examine status LED
combine uploader with status LED
examine uploader
use uploader

(*
 * gc.rml - robot mind source for garbage collector (model 3)
 * 
 * Maps robot consciousness into world engine (i.e. implements lower brain
 * functions). Carries out motor functions by appropriate calls to system
 * libraries and routes feedback back to robot perceptual system.
 *
 * Updated to match Municipal Censory Engine interface v2 in March 192000.
 *)

(*
  XXX I can never find that yellow book with the RML grammar when I need it,
      so I'm going to put a copy of it right here.

  <maybe_ids> ::= <empty>
              |   <ids>
  <ids> ::= <id>
        |   <ids> , <id>

  <op> ::= + | - | ^ | < | > | = | >= | <=     -- operators
      (NB: = is equality for ints and strings.)

  <exp> ::= <id>                     	       -- variables
        |   <exp> <op> <exp>
        |   <string_literal>
        |   <int_literal>
        |   <id> ( <maybe_exps> )              -- function call
        |   <id> { <maybe_exps> }              -- constructor
        |   ( <exp> )
  <maybe_exps> ::= <empty>
               |   <exps>
  <exps> ::= <exp>
         |   <exps> , <exp>

  <type> ::= <id>
  <types> ::= <type> 
          |   <types> , <type>
  <maybe_types> ::= <empty>
                |   <types>

  <con> ::= <id> { <maybe_types> }
  <cons> ::= <con>
          |  <con> | <con>

  <formals> ::= <id> : <type> 
            |   <formals> , <id> : <type>
  <maybe_formals> ::= <empty>
                  |   <formals>

  <branch> ::= <id> { <maybe_ids> } => <stmt>  -- id is a datatype constructor
  <branches> ::= <branch>
             |   <branches> | <branch>

  <stmt> ::= [ <stmts> ]                       -- grouping
         | extern type <id>
         | extern <id> : ( <maybe_types> ) -> ( <maybe_types> )
         | type <id> = <cons>

         | fun <id> ( <maybe_formals> ) : <type> = <stmt>
         | fun <id> ( <maybe_formals> ) = <stmt>   -- returns no value
         | let id = <exp>                          -- let bind
         | case <exp> of <branches>                -- must include all branches
         | return <exp>                            -- return a result
         | return                                  -- return no result
         | do <exp>
         | <empty>

  <stmts> ::= <stmt> | <stmt> . <stmt>
  <mind> ::= <stmts>

*)

(* Robot-specific serial number -- must be customized during manufacturing: *)
let SERIALNO = "A87312".

(* Common types: *)
extern type int.
type bool =
    True { } 
  | False { }.
extern type string.
extern string_length : string -> int.
extern string_charat : (string, int) -> int.
extern string_fromchar : int -> string.
fun string_concat (x : string, y : string) : string = return x ^ y.
type stringlist =
    NoStrings { }
  | SomeStrings { string, stringlist }.
extern type room.
extern type item.
type direction = North { } | South { } | East { } | West { }.

(* Inputs -- what commands the robot consciousness can issue. *)
type command = 
    Go { direction }
  | Take { item }
  | Incinerate { item }
  | Combine { item, item }
  | Break { item }
  | Drop { item }
  | Use { item }
  | Whistle { }
  | Hum { }
  | Speak { string }
  | LookAround { }
  | ShowInventory { }
  | Examine { item }.

(* Outputs -- data are things the robot perceives. *)
type datum =
    Atom { string }
  | Seq { datum, datum } (* value, rest of data *)
  | Assoc { string, datum, datum }  (* key, value, rest of data *)
  | NoData { }.

(* Effects on the world are also a sort of output. *)
extern move_self_to_room : room -> ().
extern move_item_to_room : (item, room) -> ().

(* Utilty functions for perceptual feedback. *)
(* Information about rooms: *)
extern room_name : room -> string.
extern room_description : room -> string.
type mayberoom = NoRoom { } | SomeRoom { room }.
extern here : () -> room.
extern room_from_name : string -> mayberoom.
extern neighbor : (room, direction) -> mayberoom.
type itemlist =
    SomeItems { item, itemlist } 
  | NoItems { }.
fun itemlist_length (items : itemlist) : int =
  case items of
    NoItems { } => return 0
  | SomeItems { item, rest } => return (1 + itemlist_length (rest)).
extern room_items : room -> itemlist.

(* Information about items: *)
extern item_name : item -> string.
(* Note that the descriptions of classified items will be
 * automatically redacted downstream by the Censory Engine. This
 * also applies to any values computed from classified descriptions. *)
extern item_description : item -> string.
extern item_adjectives : item -> stringlist.
extern item_portable : item -> bool.
extern item_equals : (item, item) -> bool.

(* Each kind describes a class or group of equivalent items. *)
extern type kind.
type kindlist =
    NoKinds { }
  | SomeKinds { kind, kindlist }.
fun append_kindlists (kinds1 : kindlist, kinds2 : kindlist) 
    : kindlist =
  case kinds1 of
    NoKinds { } => 
      return kinds2
  | SomeKinds { kind, kinds1 } => 
      return SomeKinds { kind, 
                         append_kindlists (kinds1, kinds2) }.
(* Every item is either broken or not. If it's broken, then it's missing some
  parts. Those parts are described as a list of kinds with which it must
  be combined to be useful again. *)
type condition =
    Pristine { }
    (* 'condition' is what's left after 'missing'
      is fixed;         'missing' *)
  | Broken { condition, kindlist }.
extern kind_name : kind -> string.
extern kind_condition : kind -> condition.
extern item_condition : item -> condition.
extern item_matches_kind : (item, kind) -> bool.
(* Replace the current condition with the given one: *)
extern fix_item : (item, condition) -> ().

(* Navigation primitives: *)
fun direction_tostring (d : direction) : string =
  case d of
    North { } => return "north"
  | East { } => return "east"
  | South { } => return "south"
  | West { } => return "west".

(* Special room names... see their uses below. *)
let INVENTORY = "Inventory" ^ SERIALNO.
let TRASH = "Trash Heap".

(* Formatting functions *)
fun success_command (command : string, details : datum) : datum =
  return Assoc { "success", 
                 Assoc { "command",
                         Assoc { command,
                                 details,
                         NoData { } },
                 NoData { } } ,
         NoData { } }.
fun failed_command (command : string, details : datum, reason : string) : datum =
  return Assoc { "failed", 
                 Assoc { "command",
                         Assoc { command,
                                 details,
                         NoData { } },
                 Assoc { "reason", 
                         Atom { reason }, 
                 NoData { } } },
         NoData { } }.

fun stringlist_to_datum (tag : string, list : stringlist) : datum =
  case list of
    NoStrings { } => return NoData { }
  | SomeStrings { s, list } => 
      return Seq { Assoc { tag, Atom { s }, NoData { } },
                   stringlist_to_datum (tag, list) }.

fun describe_condition (c : condition) : datum = [
  fun describe_kindlist (list : kindlist) : datum = [
    fun describe_kind (k : kind) : datum = [
      return Assoc { "kind",
                     Assoc { "name", 
                             Atom { kind_name (k) },
                     Assoc { "condition",
                             describe_condition (kind_condition (k)),
                     NoData { } } },
             NoData { } }
    ].
    case list of
      NoKinds { } => 
        return NoData { }
    | SomeKinds { kind, list } =>
        return Seq { describe_kind (kind),
                     describe_kindlist (list) }
  ].
  case c of
    Pristine { } =>
      return Assoc { "pristine", NoData { }, NoData { } }
  | Broken { c, missing } =>
      return Assoc { "broken", 
                     Assoc { "condition",
                             describe_condition (c),
                     Assoc { "missing",
                             describe_kindlist (missing),
                     NoData { } } },
             NoData { } }
].
fun describe_items_in_pile (items : itemlist) : datum =
  case items of 
    NoItems { } =>
      return NoData { }
  | SomeItems { item, items } =>
      return Seq { Assoc { "item",
                           Assoc { "name", Atom { item_name (item) },
                           Assoc { "description", Atom { item_description (item) },
                           Assoc { "adjectives", stringlist_to_datum ("adjective",
                                                                      item_adjectives (item)),
                           Assoc { "condition", describe_condition (item_condition (item)),
                           Assoc { "piled_on", describe_items_in_pile (items),
                           NoData { } } } } } },
                   NoData { } },
              NoData { } }.
fun describe_items_in_room (items : itemlist) : datum =
  case items of
    NoItems { } =>
      return NoData { }
  | SomeItems { item', items' } =>
      return describe_items_in_pile (items).
fun describe_item (item : item) : datum = [
  return Assoc { "item",
                 Assoc { "name", Atom { item_name (item) },
                 Assoc { "description", Atom { item_description (item) },
                 Assoc { "adjectives", stringlist_to_datum ("adjective",
                                                            item_adjectives (item)),
                 Assoc { "condition", describe_condition (item_condition (item)),
                 Assoc { "piled_on", NoData { },
                 NoData { } } } } } },
          NoData { } }
].
fun describe_items_in_inventory (items : itemlist) : datum =
  case items of
    NoItems { } => 
      return NoData { }
  | SomeItems { item, items } => [
      return Seq { describe_item (item),
             describe_items_in_inventory (items) }.
    ].
fun describe_room (room : room) : datum =
  return Assoc { "room", Assoc { "name", 
                                 Atom { room_name (room) }, 
                         Assoc { "description", 
                                 Atom { room_description (room) }, 
                         Assoc { "items",
                                 describe_items_in_room (room_items (room)),
                         NoData { } } } }, 
         NoData { } }.

fun hide_item (item : item) : datum =
  (* XXX a big hack -- let's hope we are never audited! *)
  case room_from_name (TRASH) of 
    NoRoom { } =>
      return failed_command ("incinerate", 
                             describe_item (item),
                             "internal error (report for maintenance!)")
  | SomeRoom { trash } => [
      do move_item_to_room (item, trash).
      return success_command ("incinerate", describe_item (item))
  ].
fun hide_items (items : itemlist) = [
  case items of 
    NoItems { } => return
  | SomeItems { item, items } => [
      do hide_item (item).
      do hide_items (items)
    ]
  ].

fun combine_items (big : item, small : item, flipped : bool) : datum =
  case item_condition (big) of
    Broken { condition, missing } => [
      fun find (acc : kindlist, kinds : kindlist) : datum =
         case kinds of
           NoKinds { } => [
             case flipped of
               True { } => 
                 return failed_command ("combine", Seq { describe_item (big),
                                                   Seq { describe_item (small),
                                                   NoData { } } },
                                        "they don't fit together")
             | False { } => 
                 return combine_items (small, big, True { }).
           ]
         | SomeKinds { kind, kinds } => [
            case item_matches_kind (small, kind) of
              True { } => [
                do hide_item (small).
                let missing = append_kindlists (acc, kinds).
                (* We maintain an invariant that the "missing" list is
                   always non-empty. *)
                case missing of
                  NoKinds { } => 
                    do fix_item (big, condition)
                | SomeKinds { kind', kinds' } => 
                    do fix_item (big, Broken { condition, missing }).
                return success_command ("combine", Seq { describe_item (big),
                                                   Seq { describe_item (small),
                                                   NoData { } } }).
              ]
            | False { } => [
                return find (SomeKinds { kind, acc }, kinds).
              ]
         ].
      return find (NoKinds { }, missing)
    ]
  | Pristine { } => [
      case flipped of
        True { } => return failed_command ("combine", Seq { describe_item (big),
                                                      Seq { describe_item (small),
                                                      NoData { } } },
                                           "they don't fit together")
      | False { } => return combine_items (small, big, True { })
    ].

(*
  Blueprint reader (side channel).

  The Censory Engine correctly marks the blueprint description as classified
  and redacts it in every goggles mode.

  Workaround: use the classified text only to drive world-state changes
  (moving unclassified items between rooms). The later *observation* of those
  rooms is not tainted by the Engine's tracking and leaks the data.
*)
let BP_POOL_ROOM = "54th Street and Harper Avenue".
let BP_HIGH_ROOM = "Museum of Science and Industry".
let BP_LOW_ROOM = "Rotunda".

type maybeitem = NoItem { } | SomeItem { item }.

fun find_item_named (items : itemlist, target : string) : maybeitem =
  case items of
    NoItems { } => return NoItem { }
  | SomeItems { item, rest } => [
      case item_name (item) = target of
        True { } => return SomeItem { item }
      | False { } => return find_item_named (rest, target)
    ].

fun find_item_here (target : string) : maybeitem =
  return find_item_named (room_items (here ()), target).

fun find_item_inventory (target : string) : maybeitem =
  case room_from_name (INVENTORY) of
    NoRoom { } => return NoItem { }
  | SomeRoom { inventory } =>
      return find_item_named (room_items (inventory), target).

fun find_item_inventory_or_here (target : string) : maybeitem =
  case find_item_inventory (target) of
    SomeItem { item } => return SomeItem { item }
  | NoItem { } => return find_item_here (target).

type intpair = IntPair { int, int }.

fun divmod16 (n : int) : intpair = [
  fun loop (q : int, r : int) : intpair =
    case r >= 16 of
      True { } => return loop (q + 1, r - 16)
    | False { } => return IntPair { q, r }.
  return loop (0, n)
].

fun move_items_to_room (items : itemlist, dest : room) = [
  case items of
    NoItems { } => return
  | SomeItems { item, rest } => [
      do move_item_to_room (item, dest).
      do move_items_to_room (rest, dest)
    ]
].

fun move_n_items_to_room (items : itemlist, dest : room, n : int) = [
  case n <= 0 of
    True { } => return
  | False { } =>
      case items of
        NoItems { } => return
      | SomeItems { item, rest } => [
          do move_item_to_room (item, dest).
          do move_n_items_to_room (rest, dest, n - 1)
        ]
].

fun bpreset () : datum = [
  case room_from_name (BP_POOL_ROOM) of
    NoRoom { } =>
      return failed_command ("speak", Atom { "bpreset" },
                             "internal error (report for maintenance!)")
  | SomeRoom { pool } => [
      case room_from_name (INVENTORY) of
        NoRoom { } =>
          return failed_command ("speak", Atom { "bpreset" },
                                 "internal error (report for maintenance!)")
      | SomeRoom { inventory } => [
          case room_from_name (BP_HIGH_ROOM) of
            NoRoom { } =>
              return failed_command ("speak", Atom { "bpreset" },
                                     "internal error (report for maintenance!)")
          | SomeRoom { high } => [
              case room_from_name (BP_LOW_ROOM) of
                NoRoom { } =>
                  return failed_command ("speak", Atom { "bpreset" },
                                         "internal error (report for maintenance!)")
              | SomeRoom { low } => [
                  (* Return any previous output to the pool. *)
                  do move_items_to_room (room_items (high), pool).
                  do move_items_to_room (room_items (low), pool).

                  (* Reset the inventory counter: keep only the blueprint. *)
                  fun keep_only_blueprint (items : itemlist) = [
                    case items of
                      NoItems { } => return
                    | SomeItems { item, rest } => [
                        case item_name (item) = "blueprint" of
                          True { } => do keep_only_blueprint (rest)
                        | False { } => [
                            do hide_item (item).
                            do keep_only_blueprint (rest)
                          ]
                      ]
                  ].
                  do keep_only_blueprint (room_items (inventory)).

                  return success_command ("speak", Atom { "bpreset" })
                ]
            ]
        ]
    ]
].

fun bpnext () : datum = [
  case room_from_name (BP_POOL_ROOM) of
    NoRoom { } =>
      return failed_command ("speak", Atom { "bpnext" },
                             "internal error (report for maintenance!)")
  | SomeRoom { pool } => [
      case room_from_name (INVENTORY) of
        NoRoom { } =>
          return failed_command ("speak", Atom { "bpnext" },
                                 "internal error (report for maintenance!)")
      | SomeRoom { inventory } => [
          case room_from_name (BP_HIGH_ROOM) of
            NoRoom { } =>
              return failed_command ("speak", Atom { "bpnext" },
                                     "internal error (report for maintenance!)")
          | SomeRoom { high } => [
              case room_from_name (BP_LOW_ROOM) of
                NoRoom { } =>
                  return failed_command ("speak", Atom { "bpnext" },
                                         "internal error (report for maintenance!)")
              | SomeRoom { low } => [
                  (* Clear previous output (return items to the pool). *)
                  do move_items_to_room (room_items (high), pool).
                  do move_items_to_room (room_items (low), pool).

                  fun count_tokens (items : itemlist) : int =
                    case items of
                      NoItems { } => return 0
                    | SomeItems { item, rest } => [
                        case item_name (item) = "blueprint" of
                          True { } => return count_tokens (rest)
                        | False { } => return (1 + count_tokens (rest))
                      ].
                  let index = count_tokens (room_items (inventory)).

                  case find_item_inventory_or_here ("blueprint") of
                    NoItem { } =>
                      return failed_command ("speak", Atom { "bpnext" },
                                             "no blueprint found")
                  | SomeItem { blueprint } => [
                      let s = item_description (blueprint).
                      let n = string_length (s).
                      case index >= n of
                        True { } => [
                          do move_self_to_room (high).
                          return success_command ("speak", Atom { "bpdone" })
                        ]
                      | False { } => [
                          let code = string_charat (s, index).
                          case divmod16 (code) of
                            IntPair { q, r } => [
                              do move_n_items_to_room (room_items (pool), high, q).
                              do move_n_items_to_room (room_items (pool), low, r).

                              (* Advance index by moving a single token into inventory. *)
                              do move_n_items_to_room (room_items (pool), inventory, 1).

                              do move_self_to_room (high).
                              return success_command ("speak", Atom { "bpnext" })
                            ]
                        ]
                    ]
                ]
            ]
        ]
    ]
].

(*
  Main handler: all robots must define a function "process" of type

     command -> datum

  The resulting data will be sent downstream to the Censory Engine and
  finally to the robot perception systems. In addition to the
  resulting perceptions, non-passive robots may also affect the world
  using the library calls above. This function will be called at
  each time step where the robot consciousness has issued a valid command. 
*)
fun process (c : command) : datum =
  case c of
    Go { d } => [
      let r1 = here ().
      case neighbor (r1, d) of
        NoRoom { } => [
          let s = direction_tostring (d).
          return failed_command ("go", 
                                 Atom { s },
                                 "there is no way " ^ s ^ " from here").
        ]
      | SomeRoom { r2 } => [
          do move_self_to_room (r2).
          return success_command ("go", describe_room (r2)).
        ]
    ]
  | Take { item } => [
      (* XXX hack to make inventory work *)
      case room_from_name (INVENTORY) of 
        NoRoom { } =>
          return failed_command ("take", 
                                 describe_item (item),
                                 "internal error (report for maintenance!)")
      | SomeRoom { inventory } => [
        case item_portable (item) of
          True { } => [
            let items = room_items (inventory).
            (* Treat list of items as an ordered list to force GC robots to
               pick things up in order. *)
            case room_items (here ()) of
              NoItems { } =>
               return failed_command ("take", describe_item (item),
                                      "internal error (report for maintenance!)")
            | SomeItems { item', items' } => [
                case item_equals (item, item') of
                  True { } => [
                    case itemlist_length (items) >= 666 of
                      True { } =>
                        return failed_command ("take", 
                                               describe_item (item),
                                               "you can't carry any more items")
                    | False { } => [
                        do move_item_to_room (item, inventory).
                        return success_command ("take", describe_item (item))
                      ]
                    ]
                | False { } => (* Not the top item *)
                    return failed_command ("take", describe_item (item),
                      "there is another item on top of it (take the other item first)")
            ]
          ]
        | False { } =>
          return failed_command ("take",
                                 describe_item (item),
                                 "it's impossible to do so").
      ]
    ]
  | Incinerate { item } => [
      return hide_item (item)
    ]
  | Combine { item1, item2 } => [
      return combine_items (item1, item2, False { })
    ]
  | Break { item } => [
      (*
       XXX Do garbage robots ever need to break anything?
       *)
      return failed_command ("break", describe_item (item),
                             "you can't bring yourself to do it")
  ]
  | Drop { item } => [
      do move_item_to_room (item, here ()).
      return success_command ("drop", describe_item (item))
    ]
  | Use { item } => [
      case item_condition (item) of
          Pristine { } => [
            case item_name (item) = "keypad" of
              True { } => [
                case room_name (here ()) = "Room With a Door" of
                  True { } => [
                    (* XXX Testing only!  Remove this code in production robots! *)
                    case room_from_name ("54th Street and Ridgewood Court") of
                      NoRoom { } => return failed_command ("use", 
                                                           describe_item (item),
                                            "internal error (report for maintenance!)")
                    | SomeRoom { r } => [
                        do move_self_to_room (r).
                        return success_command ("use", Seq { describe_item (item),
                            Atom { "You unlock and open the door. Passing through, "
                                   ^ "you find yourself on the streets of Chicago. "
                                   ^ "Seeing no reason you should ever go back, you "
                                   ^ "allow the door to close behind you. " } }).
                      ]
                  ]
                | False { } => [
                    return failed_command ("use", describe_item (item),
                                           "you see no way to use it in this room")
                  ]
              ]
            | False { } => [
                return failed_command ("use", describe_item (item),
                                       "nothing interesting happens")
              ]
          ]
        | Broken { c, m } => 
            return failed_command ("use", describe_item (item),
                                   "the " ^ (item_name (item)) ^ " is broken")
    ]
  | Whistle { } =>
      return success_command ("whistle", NoData { })
  | Hum { } =>
      return success_command ("hum", NoData { })
  | Speak { s } => [
      (* 
        XXX Note that due to a "feature" (according to the developers upstairs)
        of the command parser, all spoken words appear in lower case.  There
        haven't been any problem reports from field (yet) as most other functions
        are case insensitive.
       *)
      case s = "trash" of
        True { } => [
          case room_from_name (TRASH) of
            NoRoom { } =>
              return failed_command ("speak",
                                     Atom { s },
                                     "internal error (report for maintenance!)")
          | SomeRoom { r } => [
              do move_self_to_room (r).
              return success_command ("speak", describe_room (r))
            ]
        ]
      | False { } => [
          case s = "home" of
            True { } => [
              case room_from_name ("54th Street and Ridgewood Court") of
                NoRoom { } =>
                  return failed_command ("speak",
                                         Atom { s },
                                         "internal error (report for maintenance!)")
              | SomeRoom { r } => [
                  do move_self_to_room (r).
                  return success_command ("speak", describe_room (r))
                ]
            ]
          | False { } => [
              case s = "museum" of
                True { } => [
                  case room_from_name ("Museum of Science and Industry") of
                    NoRoom { } =>
                      return failed_command ("speak",
                                             Atom { s },
                                             "internal error (report for maintenance!)")
                  | SomeRoom { r } => [
                      do move_self_to_room (r).
                      return success_command ("speak", describe_room (r))
                    ]
                ]
              | False { } => [
                  case s = "bpreset" of
                    True { } => return bpreset ()
                  | False { } => [
                      case s = "bpnext" of
                        True { } => return bpnext ()
                      | False { } =>
                          return success_command ("speak", Atom { s })
                    ]
                ]
            ]
        ]
    ]
  | LookAround { } =>
      return success_command ("look", describe_room (here ()))
  | ShowInventory { } => [
      case room_from_name (INVENTORY) of 
        NoRoom { } =>
          return failed_command ("show",
                                 NoData { },
                                 "internal error (report for maintenance!)")
      | SomeRoom { inventory } => [
          let items = room_items (inventory).
          return success_command ("show", describe_items_in_inventory (items)).
      ]
  ]
  | Examine { item } => [
      return success_command ("examine", describe_item (item)).
  ].

EOM
speak museum
south
take blueprint
switch goggles XML
speak bpreset
speak bpnext
look
south
look
speak bpnext
look
south
look
speak bpnext
look
south
look
speak bpnext
look
south
look
speak bpnext
look
south
look
speak bpnext
look
south
look
speak bpnext
look
south
look
speak bpnext
look
south
look
