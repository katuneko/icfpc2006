## 1) まずモデルを「並列の隣接交換」として捉える

この機械は本質的に：

* 幅 (n)（列数）の「トークン（=マーブル/ひも）」がいて、初期配置は **列1に1, 列2に2, …, 列nにn**。
* 各行は、隣接ペア ((i,i+1)) の **重ならない集合**を選んで同時に swap する（`><`）。
* swap が起きたペアでは

  * 左側にいたトークンは **右に1** 動き、**plinkを1** 得る
  * 右側にいたトークンは **左に1** 動き、plinkは0
* `|` はその列では swap に参加しない（まっすぐ）

つまり「各行＝パス上の並列隣接交換（matching）」です。

---

## 2) 観測値から、各トークンの“必要移動回数”を確定させる

観測で得られるのは各入力 (x) についての

* 出口 (y)
* plink数 (z)

ここから（あなたの Notes の通り）各トークンの移動回数が確定します：

* 右移動回数 (r_x = z)
* 変位 (d_x = y - x)
* 左移動回数 (l_x = r_x - d_x = z - (y-x))（※必ず ( \ge 0) ）

さらに

* swap参加回数（そのトークンが “><” に巻き込まれた回数）
  [
  t_x = r_x + l_x
  ]

が出ます。

ここまでで重要なのは：

* **各トークン (x) が、合計で何回 swap に参加するか（(t_x)）**
* **そのうち右向きが何回か（(r_x)）／左向きが何回か（(l_x)）**

が完全に決まることです。

---

## 3) 機械の“行数” (m) を推定する（下限が効く）

行数 (m) が分からないと復元が無限に増殖します。まず **最小っぽい (m)** を狙うのが定石です。

行数の下限は少なくとも2つあります：

### 下限A：1トークンが1行でswapできるのは高々1回

1行でそのトークンが巻き込まれる swap は最大1回なので

[
m \ge \max_x t_x
]

### 下限B：1行に置ける “><” の数は高々 (\lfloor n/2 \rfloor)

全swap回数を (S) とすると

* 各 swap は「右に動いた側」だけが plink を1出す
  → 全体の swap 回数は
  [
  S = \sum_x r_x = \sum_x z_x
  ]
* よって
  [
  m \ge \left\lceil \frac{S}{\lfloor n/2 \rfloor} \right\rceil
  ]

まずは

[
m_0=\max\Big(\max_x t_x,\ \left\lceil \frac{S}{\lfloor n/2 \rfloor}\right\rceil\Big)
]

を試して、無理なら (m=m_0+1, m_0+2, ...) と増やす、が実用的です。

---

## 4) 復元は「制約充足（CSP）」として行うのが最強

目的は：

* 上から (m) 行の row（`|` と `><`）を決めて、
* 各トークン (x) が

  * 最終列 (y_x) にいる
  * 右移動回数が (r_x)
  * 左移動回数が (l_x)

を満たすこと。

これを**状態遷移**で管理します。

### 状態として持つもの

* 現在の並び `order[1..n]`
  （今その列にいるトークン番号。初期は `[1,2,...,n]`）
* 残り回数 `R[x]`（右移動残数）、`L[x]`（左移動残数）

### 1回の行（row）でできる操作

行では、隣接ペアの **重ならない集合**を選びます。

* 列 i と i+1 を swap するなら、その時点で

  * 左側トークン (a = order[i]) は `R[a] > 0` が必要（右に動くから）
  * 右側トークン (b = order[i+1]) は `L[b] > 0` が必要（左に動くから）
* swapすると

  * `R[a]--`
  * `L[b]--`
  * `order[i]` と `order[i+1]` を入れ替える

これを同一行で disjoint に複数個やる（`><` を並べる）だけ。

---

## 5) 手で解く/探索を強烈に軽くする「剪定ルール」

ここが戦略の肝です。行を適当に選ぶと爆発するので、強い“当たり前制約”で潰します。

### 剪定1：残りswap数が残り行数を超えたら即死

行 index を (k)（0始まりで上から (k) 行終わった）として残り行数が (m-k) のとき、

[
R[x]+L[x] \le m-k
]

を満たさないトークンが出た瞬間、その分岐は不可能です。

### 剪定2：「もう必ず毎行swapしないと間に合わない」トークンは強制

もし
[
R[x]+L[x] = m-k
]
なら、そのトークンは **残り全行で必ずswap参加**しないといけません。

→ その行で、そのトークンが swap できる相手（隣）を持たないなら即死。
→ swapできる隣が片側しかないなら、その swap はその行で**強制**。

これだけでかなり決まります。

### 剪定3：境界列では方向が縛られる

* トークンが列 n にいるのに `R[x] > 0` なら詰み（右に行けない）
* トークンが列 1 にいるのに `L[x] > 0` なら詰み（左に行けない）

手でやるとき特に効きます。

### 剪定4：swap候補は「左がR>0、右がL>0」の場所だけ

各行で swap を置ける候補は、今の並びで

* 左トークンがまだ右移動したい（`R>0`）
* 右トークンがまだ左移動したい（`L>0`）

の隣接ペアだけ。

この条件を満たさないところに `><` を置くことは絶対できないので、候補が一気に減ります。

---

## 6) 実際の復元の進め方（人間向けの手順）

### 手順A：まず全トークンの表を作る

列数 (n) について、各 (x) の

* (y_x)
* (r_x=z_x)
* (l_x=z_x-(y_x-x))
* (t_x=r_x+l_x)

を表にします。

### 手順B：行数 (m) を下限から決め打ちして試す

上で出した (m_0) から始める。

### 手順C：上から順に行を埋める（強制から埋める）

各行でまず：

1. **必ずswapしないといけないトークン（剪定2）**を探す
2. そのトークンが swap できる隣があるか確認
3. 片側しか無いならその swap を確定
4. 複数ある場合は分岐（ここだけ慎重に）

その後、残った列で「やっても良いswap」を詰める（ただし disjoint）。

### 手順D：最後に「出口位置」が合っているか確認

最終行まで進めたら、

* `order[y_x] == x` が全てで成立（つまり各トークンが所望の出口にいる）
* かつ `R[x]=L[x]=0`

が必要。

---

## 7) もしプログラム化するなら

**自作の探索器**は「戦略」の延長なので相性が良いです。

実装の骨格は：

* 深さ優先探索（DFS） or 反復深化（IDDFS）
* 状態 = `(row_index, order, R[], L[])`
* 1行分の “disjoint swap の集合” を列挙して遷移
* 上の剪定（特に剪定1&2&3）を毎回適用
* 同じ状態をメモ化（`order` と残数が一致したら再探索しない）

※ 1行の swap 集合の列挙は、左から見て「swapする/しない」を再帰で作ると簡単です（swapしたら次の列は飛ばす）。

---

## 8) 直感的なコツ（手でやる場合の“見方”）

* **(t_x) が大きいトークン**はほぼ毎行何かしているので、先に拘束していくと楽
* **(r_x=0)** のトークンは一度も右に行けない
  → 常に「右側の相手」として swap しないと左へ行けない（相手の右移動に付き合う側）
* **境界（列1/列n）に追い込まれているのに、まだ外向きの移動が残っている**状態は即矛盾なので、そこを避けるように swap を配置する
* 行数を最小にしたいなら、各行でできるだけ swap を詰めたくなるが、**“詰めすぎると後で方向残数が合わない”**ことがある
  → 「強制から確定し、残りは控えめに」が安全

