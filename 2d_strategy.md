以下は「2D Programming Language」系の問題（＝与えられた ASCII 図から **モジュール／箱／ワイヤ**を復元して、仕様どおりに **評価（実行）**する）を解くための実装戦略です。
ポイントは **(1) 図を“グラフ”に落とす** → **(2) 箱をデータフローとしてステップ実行する** → **(3) `use` によるモジュール呼び出しを再帰評価する**、の3段です。

---

## 1) まずやること：図を「テンプレート（静的構造）」と「インスタンス（実行状態）」に分離する

* **テンプレート（module 定義）**：
  そのモジュール内の

  * 箱の位置・コマンド AST
  * ワイヤの接続（＝連結成分）
  * 各箱の入力ワイヤID（N/W）と出力ワイヤID（S/E）
  * モジュールの入力ポート（北 `|`、西 `-`）と出力ポート（東 `-` 群）がどのワイヤIDか
    を「一度だけ」構築して保持。

* **インスタンス（module 実行1回ぶん）**：
  実行時に変化するのは

  * 各ワイヤの値（未設定/設定済み）
  * 各箱が実行済みかどうか
    だけ。テンプレートをコピーせず、**ワイヤ値配列と実行フラグ配列だけ作る**のが高速です。

`use` は「新しいインスタンス」を作ってテンプレートを同じく参照し、ワイヤ値だけ新規に持たせます。

---

## 2) パース戦略：モジュール → 箱 → コマンド → ワイヤ連結成分

### 2.1 モジュールの切り出し

入力全体は「非重複なモジュール矩形の集合」なので、まずモジュール矩形を検出します。

* 角は `,`
* 上下枠は `.`（ただし入力ポートとして上枠に `|` が1つ入り得る）
* 左右枠は `:`（ただし入力ポートとして左枠に `-` が1つ入り得る／出力ポートとして右枠に `-` が複数入り得る）

実装の楽な方法：

* グリッド全走査して `,` を見つけたら「右へ `.`/`|` を辿って次の `,`」で上辺確定
* 同様に下辺、左右辺も確認して矩形確定
* その矩形内をモジュールとして切り出す
* 左上にある `name + 空白` を読む

（競プロなら入力が正しい前提のことが多いので、厳密検証は最低限でもOK）

### 2.2 箱の検出

箱は **必ず3行構造**：

```
*====*
!cmd !
*====*
```

* 1行目：`*` + `=`+ + `*`
* 2行目：`!` + コマンド文字列 + `!`
* 3行目：同じ幅の `*` + `=`+ + `*`

なので、グリッド上で `*` を起点に

* 右へ連続 `=` → 次が `*` を確認
* 1行下で左右が `!`、間がコマンド文字列
* 2行下で同じ幅の下枠
  を確認して箱として採用。

箱の「入出力ポート」は次で決まります：

* **北入力**：上枠 `=` のどこかの直上に `v` がある（その `v` がワイヤ端）
* **西入力**：コマンド行の左 `!` の直左に `>` がある（その `>` がワイヤ端）
* **南出力**：下枠 `=` の直下にワイヤ文字（`| - + #`）が接している
* **東出力**：右 `!` の直右にワイヤ文字が接している

ここが超重要で、`v` / `>` は「箱とワイヤを繋ぐための専用コネクタ」で、普通のワイヤ文字（`| - + #`）とは別枠として扱うのがコツです。

### 2.3 コマンド文字列のパース（AST化）

箱の中身（`send`, `case`, `split`, `use`）は字句が少ないので、**字句解析→再帰下降**が堅いです。

* トークン：`send case of split use Inl Inr N W S E` と記号 `()[],` と文字列 `"name"`
* 「余計な括弧は不可」なので、式 `exp` は

  * `()`
  * `(exp, exp)`
  * `Inl exp`
  * `Inr exp`
  * `N` or `W`
    のみ。これをそのまま再帰下降で。

コマンド AST を作っておけば、実行は「ASTの評価」に落ちます。

### 2.4 ワイヤの連結成分（connected component）を作る

ワイヤは文字列ではなく **平面グラフ**です。
やることは：

1. モジュール内部（境界含む）で「ワイヤとして扱うセル」を列挙

   * `| - + #`
   * さらに箱接続用の `v` と `>` も “ワイヤ端点” として含める
   * 境界上の `|`（北入力）や `-`（西入力・東出力）も含める（ただし外側へは接続しない）

2. 各セルについて「どの方向に開いているか」を定義し、隣接セルと接続

   * `|`：上下
   * `-`：左右
   * `#`：上下左右（必ず4方向接続になるはず）
   * `+`：**上下左右が開いている“候補”だが、実際に繋がるのは隣が開いている方向だけ**
     そして仕様上は「ちょうど2方向だけ繋がる」ので、隣接が2本であることを確認（できるなら）
   * `v`：上のみ（上からワイヤが来る）
   * `>`：左のみ（左からワイヤが来る）
   * 境界の `|`/`-`：外側方向は無視して「内側に1本だけ繋がる」扱い

3. この隣接で BFS/DFS して **連結成分ID＝“1本のワイヤ”** を作る

この「連結成分ID」を作ると、値を持つのは成分ごと（1成分＝1値）になり、評価が簡単になります。

---

## 3) 実行戦略：ステップ実行（ready box）を忠実に回す

### 3.1 状態

各 module instance の実行状態は：

* `wireValue[wireId] = None | Value`
* `executed[boxId] = bool`

Value は木構造：

* Unit
* Pair(v1,v2)
* Inl(v)
* Inr(v)

### 3.2 「ready box」判定

箱は **入力が揃ったら実行可能**（北・西のうち、接続されている入力のみが対象）
したがって箱ごとに

* `inNwire`（なければ None）
* `inWwire`（なければ None）
  を持っておき、
  接続されている入力ワイヤが **どちらも値あり**なら ready。

### 3.3 ステップ実行を効率よくやる（current / next の2キュー）

仕様は「1ステップで“その時点で ready な箱”を全部実行し、次ステップへ」なので、
「ready になった瞬間に即実行」ではなく **次ステップに回す**のが安全です。

おすすめ実装：

* 各箱に `missing = 接続されている入力のうち、まだ値が無い本数` を持つ
* 初期化時に missing を計算
* `missing==0` の箱を `currentReady` に入れる
* 1ステップ：

  * `currentReady` にある箱をすべて実行（順序は任意）
  * 実行で新たにワイヤが値を得たら、そのワイヤを入力にしている箱の `missing` を減らす
    0になった箱は **nextReady** に入れる（ここが「次ステップ」）
  * `currentReady = nextReady` にして次へ
* `currentReady` が空になったら終了（デッドロック含む）

これで仕様通りの層状スケジューリングを守れます。

---

## 4) 箱の評価（ASTの評価）で気をつける失敗条件

箱の実行は「まず式 exp を評価 → それに応じて出力ワイヤに send」です。

### 4.1 exp 評価

* `N` / `W` を読むとき：

  * その入力にワイヤが繋がっていなければ **fail**
  * 繋がっていても値が無いなら、その箱は ready にならないはずだが、念のため fail 扱いでもOK

* `split exp` / `case exp of ...` は exp が期待する形でないと **fail**

  * `split` は Pair でないと fail
  * `case` は Inl/Inr でないと fail

### 4.2 send の実行

* 指定 outface 側にワイヤが繋がっていないのに送ろうとしたら **fail**（仕様どおり）
* 2個送る `send[(..),(..)]` は outface が同じなら **fail**

### 4.3 ワイヤへの値書き込み

ここは仕様が言外に要求している重要点です：

* 1つのワイヤ（連結成分）は「値を保持し続ける」
* すでに値があるワイヤに **別の値**を送ろうとすると、実行順（任意）で結果が変わってしまう

なので実装としては安全に：

* `wireValue` が None なら代入
* 既に値があるなら

  * 同じ値なら何もしない（冪等）
  * 違う値なら **fail**
    にしておくと、順序任意でも破綻しにくいです（＝データフロー言語の単一代入として自然）。

---

## 5) `use` の扱い：テンプレート呼び出し＋新規インスタンス評価

`use mod` を実行する箱について：

1. 呼び出し先モジュール `mod` のテンプレートを参照
2. この `use` 箱の **入力接続（N/W の有無）** と、モジュールが持つ入力ポート（北/西）が **一致**しないと fail
   （「inputs must match」に従う）
3. 新しい module instance を作り、

   * モジュールの入力ワイヤに、`use` 箱の入力値をセットして評価開始
4. 評価が成功し、モジュールが返した値を `use` 箱の **E 出力**へ送る
   （E 側が未接続なら fail）

### 5.1 モジュールの返り値判定

モジュールは東側に出力ポートが複数あるが、**実行終了時にちょうど1本だけ値が付いていなければ fail**。
その「1本の値」が `use` の返り値。

つまり `evalModule(mod, inN?, inW?) -> (success?, value)` を作る。

### 5.2 再帰の最適化（必要なら）

再帰が深かったり同じ入力で何度も `use` される場合は、

* `memo[(modName, inNValueOrNone, inWValueOrNone)] = (fail | value)`
  のメモ化が効きます（2Dは副作用が無いので純粋関数に近い）。

ただし Value が巨大になるとハッシュが重いので、

* Value をハッシュコンス（共有）する
* もしくは `repr` をキャッシュする
  なども検討。

---

## 6) バグりやすい箇所チェックリスト

* `v` と `>` を「ワイヤの一部」として連結成分に入れているか（ただし開いている方向は片側だけ）
* 境界上の `|` / `-` が外側に接続しない扱いになっているか
* `+` は「接続がちょうど2方向」になっているか（そしてその2方向だけで連結しているか）
* 箱の南出力は「下枠 `=` の直下にワイヤがある場所」を探しているか
  （“どの `=` の下でも良い”ので、スキャンして見つける）
* 箱の北入力は “`v` が箱の上枠のどの `=` の上にあっても良い” を反映しているか
* 「ステップ実行（ready をまとめて実行）」を守れているか（current/next の2キューが安全）
* モジュール終了時の出力判定が「東側出力ポート群のうち、値があるのがちょうど1本」になっているか

---

## まとめ：実装の骨格（超短い擬似コード）

* 事前：全モジュールを parse → template 化
* 実行：

```
evalModule(name, inN?, inW?):
  init wireValue = None
  set inputs
  init missing[box] and currentReady

  while currentReady not empty:
    nextReady = []
    for box in currentReady:
      exec(box)  // AST評価→wireへ値送る
      mark executed
      for each wire newly set:
        for each dependent box:
          missing--
          if missing==0: nextReady.add(box)
    currentReady = nextReady

  outputs = [wireValue[portWire] for port in eastOutputs]
  if exactly one is not None: return it
  else fail
```
