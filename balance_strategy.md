以下は、**Balance（BCPP）系の課題を解くための「戦略」**を、マニュアルの仕様に即して整理したものです。個別のPUZZLES問題文がまだ無いので、ここでは「どの問題にも効く考え方・定石・設計パターン」を中心にまとめます（問題文が来たら、ここから一気に具体化できます）。

---

## 1) まず押さえるべき“落とし穴”3つ

### A. レジスタは全部「間接」

* `sR[i]` / `dR[j]` 自体を演算するのではなく、**それが指すメモリ `M[ sR[i] ]` / `M[ dR[j] ]` が演算対象・格納先**です。
* つまり Balance は「メモリ上の値をメモリ上に書く」言語で、レジスタは**ポインタ**。

### B. 1命令で必ず2つ作用する（デュアル）

* `MATH` は「加算」と「減算」を別々のレジスタセットに同時に行う
* `LOGIC` は「AND」と「XOR」を別々のレジスタセットに同時に行う
  → 片方だけやりたい時でも、**もう片方の副作用を無害化**する設計が要る（後述の定石で吸収します）。

### C. IP更新が “単純な mod len” じゃない（超重要）

IPは毎ステップ後に

[
IP \leftarrow (((IP + IS)\ \bmod\ 2^{32}) \bmod L)
]

（L = length(CODE)）

これ、**ISが負のときに挙動が直感とズレます**。
例：`L=100, IP=0, IS=-1`

* 直感の `(0-1) mod 100 = 99` ではなく
* 仕様は `((2^32-1) mod 100) = 95` に飛びます

なので、**負のISを使うなら必ずこの式で計算**すること。
逆に言うと、ここは設計テクとしても使えます（後述）。

---

## 2) まず作るべき道具：最小のシミュレータ＋アセンブラ

BCPPは「短いバイト列」が勝負なので、手計算でやると破綻しやすいです。最優先は：

* **シミュレータ**：状態（IP, IS, sR[4], dR[2], M[256]）を正確に実行
* **ディスアセンブラ**：hex列→命令列（読みやすい表示）
* （できれば）**トレース**：各ステップで変化したメモリセルだけ差分表示

特に上のIP更新式（`mod 2^32`先行）と、PHYSICSの「加算→回転」を正しく入れるのが肝です。

---

## 3) 命令エンコードのチートシート

提出はhexバイト列なので、手で組む時はこれが必須です。

### 即値IMM（5-bit 2の補数）

* バイトの下位5bitがIMM
* IMMの値域：`-16..+15`
* エンコード：`imm & 0x1F`

  * 例：`-1 -> 0x1F`, `-16 -> 0x10`, `15 -> 0x0F`

### オペコード

* `SCIENCE imm`：`0x00 | (imm & 0x1F)`
* `MATH D,S1,S2`：`0x20 | (D<<4) | (S1<<2) | S2`
* `LOGIC D,S1,S2`：`0x40 | (D<<4) | (S1<<2) | S2`
* `PHYSICS imm`：`0x60 | (imm & 0x1F)`
* それ以外（opcode 100,101,110,111）は **BAIL（失敗終了）** なので基本使わない（“踏まない自信がある埋め草”以外では危険）

---

## 4) プログラム設計の基本方針（BCPP向け）

BCPPは「実行ステップ数」より「コード長（バイト数）」が主評価になりがちです。だから方針はほぼこれです：

### 方針：**短いコードをループで回して仕事をさせる**

* 5〜20バイト程度の小さいリング状コードにして
* `PHYSICS`でポインタ（sR/dR）を動かし
* `MATH/LOGIC`でメモリを加工し
* `SCIENCE`で流れ（IS）を変える/停止する

---

## 5) “副作用（デュアルの片割れ）”を無害化する定石

`MATH`や`LOGIC`は必ず2箇所を書き換えます。
解法のコツは「不要側の計算が起きても壊れない」ようにすること。

典型は次のどれかです：

### 定石A：不要側の書き込み先を“捨て場所（scratch）”にする

* `dR[D]` と `dR[D+1]` が別セルを指すので、
* **片方を最初からゴミ箱セルに固定**して、そっちは何を書いてもOKにする

（多くの問題は“触っていい未指定領域”があるので、そこをscratch化）

### 定石B：不要側の演算結果が“恒等”になるようにオペランドを用意

LOGICなら恒等が作りやすいです：

* XORの恒等：`x XOR 0 = x`
* ANDの恒等：`x AND 255 = x`

MATHなら：

* 加算恒等：`x + 0 = x`
* 減算恒等：`x - 0 = x`（ただし0の準備が必要）
* 0生成：`x - x = 0` をどこかに作れる

**問題によっては、最初からM内に0や255や1が置かれている**ことが多いので、そこを「定数セル」として活用します。

### 定石C：そもそも“デュアル側も仕事をさせる”

* 例えば MATH は “加算” と “減算” を同時にできるので、

  * 片方で目的セル更新
  * 片方で次に必要な補助値（差分、フラグ、補数など）生成
    のように、**2発同時に成果を出す**とコード長が縮みやすいです。

---

## 6) PHYSICSは「ポインタ操作の心臓部」：使い方の見取り図

PHYSICSは2つの効果がセットです：

1. `sR[0] <- sR[0] + IMM(符号付き5bit)`
2. レジスタ集合 `{ sR[0], dR[1], dR[0], sR[3], sR[2], sR[1] }` のうち
   IMMの下位bitで選ばれたもの（＋必ずsR0）を **1ステップ回転**させる

ここが重要で、**加算が先に起き、その“加算後のsR0”が回転に参加**します。
（マニュアル例の `PHYSICS -1` がまさにそれ）

### よく使う見方

* PHYSICSは「sR0を動かす」だけでなく、**“sR0に入れた値を他レジスタへ押し出す”機構**でもある
* したがって、

  * “いまsR0が持っているアドレス”をdRや他sRへ配る
  * 逆にdRや他sRに入っているアドレスをsR0へ戻す
  * そのついでに±16以内のオフセットを足す
    ができる

### 実戦テク

* **PHYSICS 0 は（実質）NOP**

  * sR0は+0、回転集合はsR0単体なので変化なし
  * “穴埋め”や“コード長調整”に便利（BAILより安全）

---

## 7) SCIENCEで作る制御フロー（if/loop/停止）の王道パターン

SCIENCEの条件は **`M[sR0] != 0` のときだけ IS を書き換える** です。
これを使うコツは「**デフォルトISを先にセットしておいて、条件が真のときだけ上書きする**」です。

### if-else（分岐）パターン

1. （必ず真になるセルをsR0で指して）`SCIENCE exitSpeed`
   → IS を “exit側”にする（デフォルト）
2. （条件セルをsR0で指して）`SCIENCE contSpeed`
   → 条件が真なら IS が contSpeed に上書き、偽なら exitSpeedのまま
3. IP更新で cont/exit に分岐

これで **「0かどうかで分岐」** が作れます。

### ループ（while）パターン

* contSpeed を “ループ本体へ戻る”速度にし
* exitSpeed を “停止ルーチンへ進む”速度にする

最後に **停止は必ず `SCIENCE 0` を “M[sR0]≠0 の状態で”踏む**こと。
（この条件を満たすために、停止直前だけ sR0 を “非0定数セル” に向ける設計がよくあります）

---

## 8) コード長を縮めるための「CODE長 L」と「IS」の選び方

Balanceは **L（コード長）をこちらで選べる** のが強烈です。
ここを設計すると、短いコードで複雑な実行軌道を作れます。

### まず無難：Lを2の冪にする

* Lが `2^n` なら `2^32 mod L = 0` なので
  IP更新が直感通り `IP = (IP + IS) mod L` になって管理が楽
* マニュアルの“負ISの罠”を消せます

### 逆に上級：わざと L を 2の冪以外にして “負ISワープ” を使う

* さっきの例のように、`IS=-1` が “ほぼ -1” じゃなくなる
* 小さい負数で、L上の狙った位置へ飛べる可能性がある
* ただし設計難度が跳ね上がるので、最短狙いの最終局面向け

### もう一つの圧縮：gcd(IS, L) を利用した「軌道の間引き」

* ISが固定の間、IPが辿る位置集合は

  * `gcd(IS, L)=1` なら全位置を巡回
  * `>1` なら一部の位置しか踏まない（サブサイクル）
* SCIENCEでISを切り替えると、**違うサブサイクルに乗り換え**られる
  → “同じLの中で複数の小プログラムを共存” させられます

---

## 9) 解法の進め方（実務的な手順）

### 手順1：問題の「触るべきセル」と「触っていいセル」を分類

* 最終状態で指定されているメモリ・レジスタだけが重要なら、

  * それ以外を scratch にできる（副作用の受け皿）

### 手順2：必要な基本操作を“マクロ”として考える

典型マクロ：

* 0の生成（`x - x`）
* コピー（`x XOR 0` / `x + 0`）
* マスク・反転（AND / XOR）
* 2セル同時更新（MATH/LOGICの両側を仕事化）
* ポインタ前進（PHYSICS +1 など）とレジスタ受け渡し（回転）

### 手順3：制御フローを「SCIENCEのデフォルト→上書き」で組む

* 分岐・ループはこれでほぼ作れます

### 手順4：最後に“停止条件”だけ別枠で必ず満たす

* `SCIENCE 0` を踏む瞬間に `M[sR0] != 0` が必須
* ここを忘れると「合ってるのに止まれない」が起きます

---

## 10) さらに攻めるなら：自動合成（探索/SMT）の方向性

BCPPは「短いコード」が欲しいので、最終的に人間の手設計だけだと限界が来がちです。以下が現実的です：

* **コード長Lを小さい方から固定**して
* （実行ステップ上限を設けて）シミュレータで

  * 目的状態到達＆停止するコードを探索
* 探索の工夫：

  * 命令候補を絞る（PHYSICS/SCIENCE中心、MATH/LOGICは必要な形だけ）
  * 対称性（S1,S2入替など）で枝刈り
  * 重要セルだけのハッシュで状態重複除去（問題による）

このへんは「問題文が分かると一気に具体化」できます。

---
