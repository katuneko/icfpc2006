この仕様でいちばん厄介なのは、**「どこを書き換えるか」を言語処理系が“逆張り”で決める**ところです。左右に同じだけマッチがあると**適用しない**ので、普通の項書き換え（TRS）をそのまま持ち込むと、簡単にデッドロックします。

そこでの定石はかなりはっきりしていて、

**「この規則がマッチする場所が、常に 1 箇所だけになる」ように設計する**

これを実現するのが戦略の核です。以下、そのための実践的な方針をまとめます。

---

## 1. まず罠を言語化する（デッドロックの原因）

O’Cult の規則適用は

* 規則が項全体にマッチすれば即適用
* そうでないなら左右の部分項を見て、マッチ数を数え、

  * 片側だけマッチ → そこへ降りる
  * 両側マッチで **数が違う** → **マッチが少ない方**へ降りる（“最も必要な所ほど聞かれない”）
  * 両側マッチで **数が同じ** → **適用しない**

という流れでした。

つまり「左右に同じ数だけ“赤い部分（書き換え可能箇所）”がある」構造が出ると、そこから先は**何も進まない**ことが起きます。
普通の評価戦略（左から評価、外側から評価、など）を期待してはいけません。

---

## 2. 基本戦略：式に「カーソル（フォーカス）」を 1 個だけ埋め込む

最強の回避策は、項の中に **“いま計算中” を表すマーカー**を入れて、

* **マーカーは常に 1 個だけ存在する**（不変条件）
* すべての計算規則は **マーカーが付いている箇所でしかマッチしない**ようにする

という作りにすることです。

こうすると各規則のマッチ箇所が（ほぼ）必ず 0 か 1 になり、
左右同数問題が起きず、O’Cult の変な“逆張り選択”を無力化できます。

実際、ICFP 2006 の O’Cult（arith/xml）でもこの系統の解法（カーソルで評価順序を強制）が広く使われています。([complang.tuwien.ac.at][1])

---

## 3. カーソル方式 A：`Down` / `Up`（ジッパ・走査）方式

これは「木を深さ優先で降りて、値になったら上に戻る」タイプの戦略です。

### 3.1 不変条件

* 項全体に `Down` または `Up` が **ちょうど 1 個だけ**入っている

### 3.2 役割

* `Down`：評価したい場所へ降りていく（主に左から）
* `Up`：その場所が“値（正規形）”になったので結果を持って戻る

### 3.3 典型パターン（設計テンプレ）

1. **降りる規則**
   `Down (F a b) => F (Down a) b` のように、まず左へ降ろす

2. **葉に到達したら反転**
   `Down <leaf> => Up <leaf>`

3. **上へ戻す規則（単項コンストラクタ）**
   `S (Up x) => Up (S x)` のように包みを上へ運ぶ

4. **二項の右へ移動**
   左を終えたら右へ：`F (Up a) b => F a (Down b)`（必要なら）

5. **本来の計算（“値の形”を見て書き換え）**
   例：加算なら左が `Z` / `S x` になった時点で
   `Add (Up Z) y => Down y`、`Add (Up (S x)) y => S (Down (Add x y))` のように進める

6. **最後にマーカー除去**
   `Up x => x`

この方式の良さは、**木構造を確実に正規形へ持っていける**こと（XML 正規化のような構造変換にも強い）です。実際、算術（arith）や XML 正規化（xml）で `Down/Up` を使った解法例があります。([complang.tuwien.ac.at][1])

---

## 4. カーソル方式 B：`Compute`（小ステップ評価）方式

もう少し短い（ことが多い）戦略として、

* `Compute` が付いている箇所で **1 ステップだけ**書き換えて
* 詰まったら外側で `Compute` を付け直す

という設計があります。

特に算術系（Add/Mult など）で「短いルール数」に寄せやすいです。実際に `Compute` を 1 回だけ出現させる前提で、`op` 変数（演算子自体を変数で受ける）を使い、**任意の二項演算に共通の“評価順序強制”ルール**を 1 本にまとめる、という縮約が使われています。([Mostly Software][2])

### 4.1 直感

* 具体的計算：`Compute (Add Z y) => ...` のように「Compute 付き」の形でだけ定義
* 評価順序の制御：`Compute (op x y) => op (Compute x) y` のように “Compute を中へ送る”
* 行き詰まり対策：`op x y => Compute (op x y)` のように “外側からやり直す”
* 終端：`Compute x => x`

**“変な適用規則”に合わせて評価器を自分で作る**感じです。

---

## 5. 「普通のTRS」から O’Cult へ落とす手順（実務フロー）

回り道に見えて一番速いのはこの順番です。

1. **まず普通の項書き換え（健全な意味での）ルールで仕様を満たす TRS を作る**
   例：`Add Z y => y;`、`Seq (Seq a b) c => ...` のような“素直な”規則

2. それを O’Cult 用に **カーソル方式でラップ**する

* `Down/Up` か `Compute` どちらかを選ぶ
* すべての“本来の規則”はカーソルが付いているときだけ発火するように変形

3. 追加で **カーソル移動（走査）規則**を入れる

* 左優先で降りる
* 必要なら右へ回す
* 上に戻す
* 最後に剥がす

4. **規則順序を調整**する（超重要）

* “具体的な計算規則”を先
* “汎用の走査・再ラップ規則”は後ろ
* いちばん最後に `Compute x => x` / `Up x => x` などの停止系

O’Cult は「適用したら最初の規則からやり直し」なので、**規則の並び＝制御構造**です。

---

## 6. 短くする（スコアを詰める）ためのコツ

スコア最適化（サイズ最小化）を狙うなら、次が効きやすいです。

* **“走査”を汎用化する**

  * `op` のような変数に演算子を受けさせて、二項演算全体の評価順序ルールを 1 本にする（`Compute` 方式で特に有効）([Mostly Software][2])
* **葉のケースをまとめる**

  * もし葉が複数あるなら `Down x => Up x` のように一般化できるか検討（ただし上位コンストラクタを先に書いて“降りる”規則を優先しないと壊れます）
* **“対称性”を作らない**

  * ルールが複数箇所にマッチする形を極力避ける（カーソル方式ならほぼ自然に避けられます）
* **右項を“値のまま”に保つ設計**

  * 例えば自然数の演算なら「左を分解し続ける」再帰に寄せると評価制御が単純

---

## 7. テスト戦略：一発で通っても信用しない

この手の問題（ICFP 2006 の Balance/O’Cult/2D）では、検証側が**解答テキストを seed にしてランダムテストを生成**していた、という話があり、たまたま通る“部分正解”が起き得ます。

なので戦略としては、

* 自前のインタプリタで **大量ランダムテスト**を回す
* もしくは同じ検証ツールを **複数回**走らせる

のどちらかを推奨します（「たまたま通った」状態を排除）。

---

## まとめ：この問題の攻略方針（短く言うと）

* **素直な書き換え規則を考える**
* それを **“カーソル 1 個”戦略で O’Cult 化**して、マッチ箇所を 1 箇所に固定

  * 構造変換が多いなら `Down/Up`
  * 算術で短さを詰めたいなら `Compute` + 演算子変数 `op` の汎用化
* **規則の順序**で制御を作る
* **ランダム検証対策**で繰り返しテスト
