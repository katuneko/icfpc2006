

















































12:00:00 1/1/19100
Welcome to Universal Machine IX (UMIX).

This machine is a shared resource. Please do not log
in to multiple simultaneous UMIX servers. No game playing
is allowed.

Please log in (use 'guest' for visitor access).
;login: password: logged in as ohmega


% From: ohmega@cbv.net
Newsgroups: cult.cbv.discuss
Message-ID: <82F28FD4.A4DE@cbv.net>
Date: 23 Jul 19106 13:11:57
X-Organization: Cult of the Bound Variable
Subject: 2D the Ultimate Programming Language?


Hey 2D users,

 You may have noticed my colleague Harmonious Monk's recent release of
his O'Cult language.  I've tried to convince him that O'Cult is based
on misguided anti-modular design principles, but with all the grant
tablets available for Advice research, he won't give it up.

 Clearly, the 2D module system is more powerful than O'Cult.  I'd like
to demonstrate this by implementing O'Cult using 2D modules.
Unfortunately, with the Principles Of Sand Languages deadline
approaching, I don't have time to hammer out an implementation.  Perhaps
one of you would like to undertake this challenge?  

 I've modified verify to accept "ocult" tests.  Your program should
supply a module "step" which accepts a 2D-encoded O'Cult program
(defined below) on its West input, and outputs the result of applying
the supplied advice to the supplied O'Cult term exactly once.

The function [[-]] represents an O'Cult program as data in 2D:

   We think of the names used in variables and constants as numbers 
   and represent them as follows:
   [[zero]] = Inl ()
   [[s(n)]] = Inr [[n]] 

   Representation of terms:
   [[App(e1,e2)]] = Inl ([[e1]], [[e2]])
   [[Const s]]    = Inr [[s]]

   Representation of patterns:
   [[App(p1,p2)]] = Inl ([[p1]], [[p2]])
   [[Const s]]    = Inr Inl [[s]]
   [[Var s]]      = Inr Inr [[s]]

   Representation of rules:
   [[p1 => p2]]    = ([[p1]], [[p2]])

   A sentence of advise is represented as a list of patterns, 
   where lists are represented as follows:
   [[nil]]       = Inl ()
   [[cons(h,t)]] = Inr ([[h]], [[t]])

 For example, the O'Cult program 

    Add Z y => y; 

 which is a list with a single rule

    App(App(Const 0, Const 1), Var 2) => Var 2

 and so is represented by the 2D value

    Inr ((Inl (Inl (Inr Inl Inl (),
		    Inr Inl Inr Inl ()),
	       Inr Inr Inr Inr Inl ()),
	  Inr Inr Inr Inr Inl ()),
	 Inl ())

 Your step module will be suppled the representation of an (advice,term)
pair, and should output the term that results from applying the advice
once to term.

 As incentive, I'll be happy to provide anyone who completes the
O'Cult-in-2D interpreter with a copy of my forthcoming book, 
"Type Sand Programming Languages".

- Bill

---------------------------------------------
 Bill Ohmega     "Hell is other programming
ohmega@cbv.net    languages." -- Sartran
---------------------------------------------
% From: ohmega@cbv.net
Newsgroups: cult.cbv.discuss
Message-ID: <82F68FA4.A4DE@cbv.net>
Date: 19 Jul 19106 13:51:51
X-Organization: Cult of the Bound Variable
Subject: Is this thing on??

Hey,

 I sent out an announcement for 2D almost a month ago. Is anybody in
newsland using it? I've been using it in my undergraduate class
"Introduction to Programming Languages" this semester with great
success. The students love it!

 Let me make a challenge: I've attached an implementation of addition
for unary numbers (0 is represented as Inr (), 1 as Inl(Inr ()),
2 as Inl(Inl(Inr ())) and so on) in 2D. See if you can write a module
called "mult" (you can even use my "plus" module) whose output is
the product of its north and west inputs. The first one to send me
a correct solution gets a package of gobstoppers!

- Bill

---------------------------------------------
 Bill Ohmega     "Hell is other programming
ohmega@cbv.net    languages." -- Sartran
---------------------------------------------


** Attachment 'plus.2d' converted of type text/2d **

% From: <Sam Tertbokim> sam@ccc.edu
Newsgroups: comp.lang.functional
Message-ID: <16BC2AD0.55A0@edu.ccc>
Date: 12 Jul 19106 14:11:21
X-Organization: Undergraduate Department, Cult Community College
Subject: Reversing a List, please help!


Please help!

I need to write a program that reverses a list. 

Can someone please send me the code that reverses a list.

I need the program to do this:

---------------------------------------------------------------------
Problem 1 [45pts]. 
Create a module called "rev" that reverses the list of elements
received along its North input. The list of elements E1, E2, E3, ...
En is represented as follows:

Inl(E1, Inl(E2, Inl(E3, ... Inl(En, Inr ()) ...)))

The module should send along its east output:

Inl(En, ... Inl(E3, Inl(E2, Inl(E1, Inr ()))) ...)
---------------------------------------------------------------------



Please help I do not know how to do this and I need to do it by tomorrow.

HELP THANK YOU!!!!!

Sam


PS what is a monad

% From: ohmega@cbv.net
Newsgroups: cult.cbv.discuss
Message-ID: <67BC2AC4.F4C0@cbv.net>
Date: 19 Jul 19106 17:21:07
X-Organization: Cult of the Bound Variable
Subject: Ray Tracing


Dearest friends,

I have discovered the most amazing application of the Computing
Device! It is a simulator that replicates the human viewing
interaction of geometry. I call it a "Ray Tracer" because it operates
along a ray.

== Ray Tracing ==

Suppose the eye is looking along a one-dimensional ray, and can see a
series of n zero-dimensional surfaces. Each surface has four qualities:

 * D, the direction it faces (either Towards or Away from the eye)
 * R, its reflectance
 * T, its translucence
 * E, its emission

We call these surfaces S1, S2, ... Sn, where S1 is closest to the eye.
Adjacent to each surface are two ray segments; the ones pointing
towards the eye are called Li and the ones facing away are called Ri.
The rays adjacent to Sj that are closer to the eye are called L(j-1)
and R(j-1); the two farther away are called Lj and Rj.

       L0        L1        L2              Ln
  eye <=====> * <=====> * <=====> * ... * <=====> (empty space)
          R0  S1    R1  S2    R2  S3    Sn    Rn 

Each ray segment has an intensity value determined by a set of
equations. Ray Tracing consists of determining the value of the ray
L0, which is the intensity that the eye sees.

Intensity can take on three values: All, Medium, and None. These are
also the values that the R, T, and E components of surfaces can take
on. The following tables define the operations + and * on these
values.

   +   | None   Medium   All
------------------------------
None   | None   Medium   All
Medium | Medium All      All
All    | All    All      All

   *   | None   Medium   All
------------------------------
None   | None   None     None
Medium | None   Medium   Medium
All    | None   Medium   All


The rays satisfy the following equations:

Ln = None
R0 = None

For i such that 0 <= i < n:
Li = if S(i + 1).D = Towards
     then (S(i + 1).R * Ri) +
          (S(i + 1).T * L(i + 1)) +
          S(i + 1).E
     else L(i + 1)

For i such that 0 < i <= n:
Ri = if Si.D = Away
     then (Si.R * Li) +
          (Si.T * R(i - 1)) +
          Si.E
     else R(i - 1)

== Representation ==

The ray-tracer consists of a module "main" with a single input along
the direction N, which is the sequence of surfaces. Its output is
a single intensity value, the darkest correct value of L0.

Intensity values are represented as follows:
None    =   Inl ()
Medium  =   Inr Inl ()
All     =   Inr Inr Inl ()

Surface orientations are represented as follows:
Towards =   Inl ()
Away    =   Inr ()

A single surface with components D, R, T and E is represented 
as follows:

(D, (R, (T, E)))

The list of surfaces S1..Sn is represented as follows:

Inl(S1, Inl(S2, Inl(S3, ... Inl(Sn, Inr()) ... )))

---------------------------------------------
 Bill Ohmega      "Hell is other programming
ohmega@cbv.net     languages." -- Sartran
---------------------------------------------
% UMIX shutdown: console EOF
